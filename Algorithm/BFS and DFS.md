# BFS and DFS

广度优先搜索（Breadth-First Search，简称 BFS）和深度优先搜索（Depth-First Search，简称 DFS）是两种经典的图遍历算法，广泛应用于解决图论、树结构以及各种搜索问题。它们的核心思想是从一个起始点开始，按照特定的规则逐步探索图或树中的所有节点。以下是对这两种算法的详细介绍：

## 一、广度优先搜索（BFS）

### 1. 算法概述

广度优先搜索是一种**逐层扩展**的搜索方法。它从起始节点出发，首先访问其所有相邻节点，然后依次访问这些相邻节点的未访问邻居节点，直到遍历完所有节点。

### 2. 算法特点

- **按层次扩展**：BFS 按照距离起始节点的“层数”逐层扩展，因此可以保证找到最短路径（在无权图中）。
- **使用队列**：BFS 使用队列（FIFO，先进先出）来存储待访问的节点。
- **空间复杂度较高**：由于需要存储每一层的所有节点，BFS 的空间复杂度通常较大。

### 3. 算法步骤

1. 初始化一个队列，并将起始节点加入队列。
2. 标记起始节点为已访问。
3. 从队列中取出第一个节点，访问该节点，并将其所有未访问的邻居节点加入队列。
4. 重复上述过程，直到队列为空。

### 4. 应用场景

- 寻找最短路径（如迷宫问题、社交网络中的最短关系链）。
- 检测图的连通性。
- 拓扑排序（结合其他算法）。

### 5. 示例代码

以下是 BFS 的 Python 实现：

```python
from collections import deque

def bfs(graph, start):
    visited = set()  # 记录已访问的节点
    queue = deque([start])  # 初始化队列
    visited.add(start)

    while queue:
        node = queue.popleft()  # 取出队首节点
        print(node, end=" ")  # 访问当前节点

        for neighbor in graph[node]:  # 遍历当前节点的所有邻居
            if neighbor not in visited:  # 如果邻居未访问过
                visited.add(neighbor)
                queue.append(neighbor)

# 示例图（邻接表表示）
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

bfs(graph, 'A')  # 输出：A B C D E F
```

## 二、深度优先搜索（DFS）

### 1. 算法概述

深度优先搜索是一种**优先深入**的搜索方法。它从起始节点出发，沿着一条路径尽可能深地探索，直到到达终点或无法继续前进时，再回溯到上一个节点，继续探索其他路径。

### 2. 算法特点

- **优先深入**：DFS 会沿着一条路径不断深入，直到不能再继续为止。
- **使用栈**：DFS 可以通过递归实现（隐式栈），也可以显式使用栈（LIFO，后进先出）。
- **空间复杂度较低**：相比 BFS，DFS 的空间复杂度较低，因为它只需要存储当前路径上的节点。

### 3. 算法步骤

1. 从起始节点开始，标记为已访问。
2. 访问该节点，并选择一个未访问的邻居节点作为下一个节点。
3. 对新节点重复上述过程，直到没有未访问的邻居节点。
4. 回溯到上一个节点，继续探索其他未访问的邻居节点。
5. 重复上述过程，直到所有节点都被访问。

### 4. 应用场景

- 图的连通性检测。
- 拓扑排序。
- 解决迷宫问题（寻找任意路径）。
- 寻找强连通分量。

### 5. 示例代码

以下是 DFS 的两种实现方式：

#### **递归实现**

```python
def dfs_recursive(graph, node, visited):
    visited.add(node)  # 标记当前节点为已访问
    print(node, end=" ")  # 访问当前节点

    for neighbor in graph[node]:  # 遍历当前节点的所有邻居
        if neighbor not in visited:  # 如果邻居未访问过
            dfs_recursive(graph, neighbor, visited)

# 示例图（邻接表表示）
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

visited = set()
dfs_recursive(graph, 'A')  # 输出：A B D E F C
```

#### **迭代实现（显式栈）**

```python
def dfs_iterative(graph, start):
    visited = set()  # 记录已访问的节点
    stack = [start]  # 初始化栈

    while stack:
        node = stack.pop()  # 取出栈顶节点
        if node not in visited:  # 如果节点未访问过
            visited.add(node)
            print(node, end=" ")  # 访问当前节点

            # 将当前节点的所有邻居节点逆序入栈（保证顺序与递归一致）
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)

# 示例图（邻接表表示）
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

dfs_iterative(graph, 'A')  # 输出：A B D E F C
```

---

## 三、BFS 和 DFS 的对比

| 特性                 | 广度优先搜索（BFS）                    | 深度优先搜索（DFS）                  |
| -------------------- | -------------------------------------- | ------------------------------------ |
| **数据结构**         | 队列（FIFO）                           | 栈（LIFO）或递归                     |
| **搜索顺序**         | 按层次逐层扩展                         | 优先深入探索                         |
| **适用场景**         | 寻找最短路径、连通性检测               | 迷宫问题、拓扑排序、强连通分量       |
| **空间复杂度**       | 较高（O(V + E)，V 是节点数，E 是边数） | 较低（O(V) 或 O(E)，取决于实现方式） |
| **时间复杂度**       | O(V + E)                               | O(V + E)                             |
| **是否保证最短路径** | 是（在无权图中）                       | 否                                   |

---

## 四、总结

- **BFS 和 DFS 的选择**：如果需要找到最短路径（如在无权图中），优先选择 BFS；如果只需要遍历所有节点或解决拓扑排序等问题，DFS 更加灵活且节省空间。
- **实际应用**：在实际问题中，可以根据具体需求选择合适的算法。例如，在社交网络中寻找两个人之间的最短关系链，BFS 是更优的选择；而在解决复杂的迷宫问题时，DFS 可能更高效。

如果你对某个应用场景或实现细节有进一步的疑问，请随时补充说明！
